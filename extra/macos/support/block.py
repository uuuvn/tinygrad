import ctypes, ctypes.util

CoreServices = ctypes.CDLL(ctypes.util.find_library("CoreServices"))

# Blocks are apple's extension to C to make closures that can capture variables
# Normally this struct is generated by compiler
# There are some pieces of documentation in llvm about it
# When fields other that invoke aren't read ctypes.byref(callback, -0x10) works just fine
def blockify(fn, rtype, *argtypes):
  class Descriptor(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
      ('reserved', ctypes.c_uint64),
      ('size', ctypes.c_uint64),
      ('copy_helper', ctypes.CFUNCTYPE(None, ctypes.POINTER(None), ctypes.POINTER(None))),
      ('dispose_helper', ctypes.CFUNCTYPE(None, ctypes.POINTER(None))),
      ('signature', ctypes.POINTER(ctypes.c_char)),
    ]

  class Literal(ctypes.Structure):
    _pack_ = 1
    _fields_ = [
      ('isa', ctypes.POINTER(None)),
      ('flags', ctypes.c_int32),
      ('reserved', ctypes.c_int32),
      ('invoke', ctypes.CFUNCTYPE(rtype, ctypes.POINTER(Descriptor), *argtypes)),
      ('descriptor', ctypes.POINTER(Descriptor)),
    ]

  return ctypes.pointer(Literal(
    isa = ctypes.addressof(CoreServices._NSConcreteGlobalBlock),
    flags = (1 << 28), # BLOCK_IS_GLOBAL
    reserved = 0,
    invoke = ctypes.CFUNCTYPE(rtype, ctypes.POINTER(Descriptor), *argtypes)(lambda *args: fn(*args[1:])),
    descriptor = ctypes.pointer(Descriptor(
      reserved = 0,
      size = ctypes.sizeof(Literal),
      copy_heper = ctypes.CFUNCTYPE(None, ctypes.POINTER(None), ctypes.POINTER(None))(0),
      dispose_helper = ctypes.CFUNCTYPE(None, ctypes.POINTER(None))(0),
      signature = None
    )),
  ))